// Unicode character mappings for LinkedIn-compatible text formatting

const boldMap: Record<string, string> = {
  'A': '\u{1D5D4}', 'B': '\u{1D5D5}', 'C': '\u{1D5D6}', 'D': '\u{1D5D7}', 'E': '\u{1D5D8}',
  'F': '\u{1D5D9}', 'G': '\u{1D5DA}', 'H': '\u{1D5DB}', 'I': '\u{1D5DC}', 'J': '\u{1D5DD}',
  'K': '\u{1D5DE}', 'L': '\u{1D5DF}', 'M': '\u{1D5E0}', 'N': '\u{1D5E1}', 'O': '\u{1D5E2}',
  'P': '\u{1D5E3}', 'Q': '\u{1D5E4}', 'R': '\u{1D5E5}', 'S': '\u{1D5E6}', 'T': '\u{1D5E7}',
  'U': '\u{1D5E8}', 'V': '\u{1D5E9}', 'W': '\u{1D5EA}', 'X': '\u{1D5EB}', 'Y': '\u{1D5EC}',
  'Z': '\u{1D5ED}',
  'a': '\u{1D5EE}', 'b': '\u{1D5EF}', 'c': '\u{1D5F0}', 'd': '\u{1D5F1}', 'e': '\u{1D5F2}',
  'f': '\u{1D5F3}', 'g': '\u{1D5F4}', 'h': '\u{1D5F5}', 'i': '\u{1D5F6}', 'j': '\u{1D5F7}',
  'k': '\u{1D5F8}', 'l': '\u{1D5F9}', 'm': '\u{1D5FA}', 'n': '\u{1D5FB}', 'o': '\u{1D5FC}',
  'p': '\u{1D5FD}', 'q': '\u{1D5FE}', 'r': '\u{1D5FF}', 's': '\u{1D600}', 't': '\u{1D601}',
  'u': '\u{1D602}', 'v': '\u{1D603}', 'w': '\u{1D604}', 'x': '\u{1D605}', 'y': '\u{1D606}',
  'z': '\u{1D607}',
  '0': '\u{1D7EC}', '1': '\u{1D7ED}', '2': '\u{1D7EE}', '3': '\u{1D7EF}', '4': '\u{1D7F0}',
  '5': '\u{1D7F1}', '6': '\u{1D7F2}', '7': '\u{1D7F3}', '8': '\u{1D7F4}', '9': '\u{1D7F5}',
};

const italicMap: Record<string, string> = {
  'A': '\u{1D608}', 'B': '\u{1D609}', 'C': '\u{1D60A}', 'D': '\u{1D60B}', 'E': '\u{1D60C}',
  'F': '\u{1D60D}', 'G': '\u{1D60E}', 'H': '\u{1D60F}', 'I': '\u{1D610}', 'J': '\u{1D611}',
  'K': '\u{1D612}', 'L': '\u{1D613}', 'M': '\u{1D614}', 'N': '\u{1D615}', 'O': '\u{1D616}',
  'P': '\u{1D617}', 'Q': '\u{1D618}', 'R': '\u{1D619}', 'S': '\u{1D61A}', 'T': '\u{1D61B}',
  'U': '\u{1D61C}', 'V': '\u{1D61D}', 'W': '\u{1D61E}', 'X': '\u{1D61F}', 'Y': '\u{1D620}',
  'Z': '\u{1D621}',
  'a': '\u{1D622}', 'b': '\u{1D623}', 'c': '\u{1D624}', 'd': '\u{1D625}', 'e': '\u{1D626}',
  'f': '\u{1D627}', 'g': '\u{1D628}', 'h': '\u{1D629}', 'i': '\u{1D62A}', 'j': '\u{1D62B}',
  'k': '\u{1D62C}', 'l': '\u{1D62D}', 'm': '\u{1D62E}', 'n': '\u{1D62F}', 'o': '\u{1D630}',
  'p': '\u{1D631}', 'q': '\u{1D632}', 'r': '\u{1D633}', 's': '\u{1D634}', 't': '\u{1D635}',
  'u': '\u{1D636}', 'v': '\u{1D637}', 'w': '\u{1D638}', 'x': '\u{1D639}', 'y': '\u{1D63A}',
  'z': '\u{1D63B}',
};

const boldItalicMap: Record<string, string> = {
  'A': '\u{1D63C}', 'B': '\u{1D63D}', 'C': '\u{1D63E}', 'D': '\u{1D63F}', 'E': '\u{1D640}',
  'F': '\u{1D641}', 'G': '\u{1D642}', 'H': '\u{1D643}', 'I': '\u{1D644}', 'J': '\u{1D645}',
  'K': '\u{1D646}', 'L': '\u{1D647}', 'M': '\u{1D648}', 'N': '\u{1D649}', 'O': '\u{1D64A}',
  'P': '\u{1D64B}', 'Q': '\u{1D64C}', 'R': '\u{1D64D}', 'S': '\u{1D64E}', 'T': '\u{1D64F}',
  'U': '\u{1D650}', 'V': '\u{1D651}', 'W': '\u{1D652}', 'X': '\u{1D653}', 'Y': '\u{1D654}',
  'Z': '\u{1D655}',
  'a': '\u{1D656}', 'b': '\u{1D657}', 'c': '\u{1D658}', 'd': '\u{1D659}', 'e': '\u{1D65A}',
  'f': '\u{1D65B}', 'g': '\u{1D65C}', 'h': '\u{1D65D}', 'i': '\u{1D65E}', 'j': '\u{1D65F}',
  'k': '\u{1D660}', 'l': '\u{1D661}', 'm': '\u{1D662}', 'n': '\u{1D663}', 'o': '\u{1D664}',
  'p': '\u{1D665}', 'q': '\u{1D666}', 'r': '\u{1D667}', 's': '\u{1D668}', 't': '\u{1D669}',
  'u': '\u{1D66A}', 'v': '\u{1D66B}', 'w': '\u{1D66C}', 'x': '\u{1D66D}', 'y': '\u{1D66E}',
  'z': '\u{1D66F}',
};

function convertChar(char: string, bold: boolean, italic: boolean): string {
  if (bold && italic && boldItalicMap[char]) {
    return boldItalicMap[char];
  }
  if (bold && boldMap[char]) {
    return boldMap[char];
  }
  if (italic && italicMap[char]) {
    return italicMap[char];
  }
  return char;
}

function convertText(text: string, bold: boolean, italic: boolean, underline: boolean, strike: boolean): string {
  let result = text.split('').map(char => convertChar(char, bold, italic)).join('');

  // Apply combining characters for underline and strikethrough
  if (underline) {
    result = result.split('').map(char => char + '\u0332').join('');
  }
  if (strike) {
    result = result.split('').map(char => char + '\u0336').join('');
  }

  return result;
}

interface TextNode {
  text: string;
  bold?: boolean;
  italic?: boolean;
  underline?: boolean;
  strike?: boolean;
}

function parseHtmlNode(node: Node, styles: { bold: boolean; italic: boolean; underline: boolean; strike: boolean }): string {
  if (node.nodeType === Node.TEXT_NODE) {
    return convertText(node.textContent || '', styles.bold, styles.italic, styles.underline, styles.strike);
  }

  if (node.nodeType === Node.ELEMENT_NODE) {
    const element = node as Element;
    const tagName = element.tagName.toLowerCase();

    const newStyles = { ...styles };

    if (tagName === 'strong' || tagName === 'b') {
      newStyles.bold = true;
    }
    if (tagName === 'em' || tagName === 'i') {
      newStyles.italic = true;
    }
    if (tagName === 'u') {
      newStyles.underline = true;
    }
    if (tagName === 's' || tagName === 'strike' || tagName === 'del') {
      newStyles.strike = true;
    }

    let result = '';

    if (tagName === 'br') {
      return '\n';
    }

    if (tagName === 'p') {
      const childContent = Array.from(node.childNodes)
        .map(child => parseHtmlNode(child, newStyles))
        .join('');
      return childContent + '\n\n';
    }

    if (tagName === 'li') {
      const childContent = Array.from(node.childNodes)
        .map(child => parseHtmlNode(child, newStyles))
        .join('');
      return '• ' + childContent + '\n';
    }

    if (tagName === 'ul') {
      return Array.from(node.childNodes)
        .filter(child => child.nodeType === Node.ELEMENT_NODE && (child as Element).tagName.toLowerCase() === 'li')
        .map(li => {
          const liContent = Array.from(li.childNodes)
            .map(c => parseHtmlNode(c, newStyles))
            .join('');
          return '• ' + liContent.trim() + '\n';
        })
        .join('');
    }

    if (tagName === 'ol') {
      const start = parseInt(element.getAttribute('start') || '1', 10);
      return Array.from(node.childNodes)
        .filter(child => child.nodeType === Node.ELEMENT_NODE && (child as Element).tagName.toLowerCase() === 'li')
        .map((li, idx) => {
          const liContent = Array.from(li.childNodes)
            .map(c => parseHtmlNode(c, newStyles))
            .join('');
          return `${start + idx}. ` + liContent.trim() + '\n';
        })
        .join('');
    }

    result = Array.from(node.childNodes)
      .map(child => parseHtmlNode(child, newStyles))
      .join('');

    return result;
  }

  return '';
}

export function htmlToUnicode(html: string): string {
  if (typeof window === 'undefined') {
    return html;
  }

  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');

  const result = parseHtmlNode(doc.body, {
    bold: false,
    italic: false,
    underline: false,
    strike: false,
  });

  // Clean up extra newlines
  return result.replace(/\n{3,}/g, '\n\n').trim();
}

export function htmlToPlainText(html: string): string {
  if (typeof window === 'undefined') {
    return html;
  }

  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');

  function extractText(node: Node): string {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.textContent || '';
    }

    if (node.nodeType === Node.ELEMENT_NODE) {
      const element = node as Element;
      const tagName = element.tagName.toLowerCase();

      if (tagName === 'br') {
        return '\n';
      }

      if (tagName === 'p') {
        const childContent = Array.from(node.childNodes).map(extractText).join('');
        return childContent + '\n\n';
      }

      if (tagName === 'ul') {
        return Array.from(node.childNodes)
          .filter(child => child.nodeType === Node.ELEMENT_NODE && (child as Element).tagName.toLowerCase() === 'li')
          .map(li => '• ' + Array.from(li.childNodes).map(extractText).join('').trim() + '\n')
          .join('');
      }

      if (tagName === 'ol') {
        const start = parseInt((node as Element).getAttribute('start') || '1', 10);
        return Array.from(node.childNodes)
          .filter(child => child.nodeType === Node.ELEMENT_NODE && (child as Element).tagName.toLowerCase() === 'li')
          .map((li, idx) => `${start + idx}. ` + Array.from(li.childNodes).map(extractText).join('').trim() + '\n')
          .join('');
      }

      return Array.from(node.childNodes).map(extractText).join('');
    }

    return '';
  }

  return extractText(doc.body).replace(/\n{3,}/g, '\n\n').trim();
}
